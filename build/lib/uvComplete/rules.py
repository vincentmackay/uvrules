#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Thu Feb 15 12:27:51 2024@author: vincent"""import numpy as npimport matplotlib.pyplot as pltfrom IPython.display import display, clear_outputimport itertoolsimport picklefrom utils import check_fulfillment, get_array_size, get_n_new_fulfilled, get_min_distance_from_new_point, collision_checkdef create_long_rules_array(commanded, diameter = 8.54, max_array_size = 300, fulfill_tolerance = 0.5, show_plot = True, save_file = False):    if show_plot:        fig,ax = plt.subplots(1,3,figsize=(15,5))        # Build the first dish    built = np.array([[0,0]])    print('Before even beginning, have:')    print('{:d} antennas built'.format(built.shape[0]))        order = -1 # set to -1 to start with longest baselines, otherwise it starts with shortest        # sort by longest to shortest baseline    commanded = commanded[np.argsort(order * np.linalg.norm(commanded, axis=1))]        newly_fulfilled_points = []        not_fulfilled = np.copy(commanded)        # do the first iteration, which is trivial    built = np.vstack([built, not_fulfilled[0]])    n_fulfilled, n_not_fulfilled, fulfilled, not_fulfilled = check_fulfillment(commanded,built, fulfill_tolerance)            while(not_fulfilled.shape[0]>=1):        max_new_fulfilled = 0        min_built_size = get_array_size(built)        max_min_distance_from_new = 0        success = False        favored_i = 0        favored_flip = 1        favored_k = 0        # iterate over all combinations of built antennas and unfulfilled uv point        for i,k in itertools.product(range(built.shape[0]), range(not_fulfilled.shape[0])):            # try both the positive and negative position            for flip in [1,-1]:                new_antpos = built[i] + flip * not_fulfilled[k]                                # try and add one antenna at the longest commanded-but-not-fulfilled distance from point i                built_temp = np.vstack([built, new_antpos]) # 50 us                # check how many are newly fulfilled                n_new_fulfilled = get_n_new_fulfilled(new_antpos,built,not_fulfilled, fulfill_tolerance) # 15 ms                # check what's the shortest distance of the new point from any already built antenna                min_distance_from_new = get_min_distance_from_new_point(built, new_antpos) # 215 us                                # also check the size of the array                built_temp_size = get_array_size(built_temp) #241 us                                # check if there's no collision and that we're still within max size                if (not collision_check(built_temp,diameter)) and built_temp_size<max_array_size: #245 us                    success = True                    if n_new_fulfilled > max_new_fulfilled:                        max_new_fulfilled = n_new_fulfilled                        favored_i = i                        favored_k = k                        favored_flip = flip                    elif n_new_fulfilled == max_new_fulfilled:                        if min_distance_from_new > max_min_distance_from_new:                            max_min_distance_from_new = min_distance_from_new                            favored_i = i                            favored_flip = flip                            favored_k = k                        elif min_distance_from_new == max_min_distance_from_new:                            if built_temp_size < min_built_size:                                min_built_size = built_temp_size                                favored_i = i                                favored_flip = flip                                favored_k = k                        if success == False:            print('Array is full for this set of parameters, quitting.')            return built            break                    built = np.vstack([built,built[favored_i] + favored_flip*not_fulfilled[favored_k]])        n_fulfilled, n_not_fulfilled, fulfilled, not_fulfilled = check_fulfillment(commanded,built, fulfill_tolerance)        not_fulfilled = not_fulfilled[np.argsort(order * np.linalg.norm(not_fulfilled, axis=1))]                newly_fulfilled_points.append(max_new_fulfilled)                if show_plot:            clear_output(wait=True)            plt.pause(0.01)            #built_uvs = antpos_to_uv(built)            ax[0].plot(commanded[:,0],commanded[:,1],color='k',alpha=0.15,label='Commanded points')            ax[0].plot(fulfilled[:,0],fulfilled[:,1],color='#00ff00',label='Fulfilled points')            ax[0].set_title('uv plane')            ax[0].set_xlabel(r'$u$')            ax[0].set_ylabel(r'$v$')            #ax[0].legend()            ax[1].scatter(*zip(*built),marker='o', s=20,color='k')            ax[1].set_title('Array')            ax[1].set_xlabel('EW')            ax[1].set_ylabel('NS')            ax[2].plot(range(len(newly_fulfilled_points)),newly_fulfilled_points,color='k')            ax[2].set_ylabel('Number of newly fulfilled points')            ax[2].set_xlabel('New antenna rank')            for i in range(2):                ax[i].set_aspect('equal', adjustable='box')            display(fig)            #if built.shape[0]%10==0:        print('Array size is now: {:.2f} wavelengths'.format(min_built_size))        print('{:d} newly fulfilled points'.format(max_new_fulfilled))        print('{:d} total antennas built'.format(built.shape[0]))        print('{:d}/{:d} commanded points remain to be fulfilled'.format(not_fulfilled.shape[0],commanded.shape[0]))        plt.close()    if save_file:        # Saving the variable to disk        with open('built_algo1.pkl', 'wb') as file:            pickle.dump(built, file)    return built    print('Done.')