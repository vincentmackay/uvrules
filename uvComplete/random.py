#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Thu Feb 15 12:27:51 2024@author: vincent"""import numpy as npimport matplotlib.pyplot as pltfrom scipy.spatial import cKDTreefrom IPython.display import clear_output, displayfrom uvComplete.utils import check_fulfillment, get_array_size, get_n_new_fulfilleddef create_array_random(n=200, commanded = -1, diameter=8.54,max_array_size=300, fulfill_tolerance = 0.5, show_plot = True, show_plot_skip = 10, verbose = True,max_failed_attempts = 100000, random_seed = 11141):    # Initialize built array with a single random point    np.random.seed(random_seed)        if show_plot:        fig,ax = plt.subplots(1,3,figsize=(15,5))        if isinstance(commanded, np.ndarray):        try_fulfill = True        n_not_fulfilled = commanded.shape[0]    elif isinstance(commanded, int):        try_fulfill = False        n_not_fulfilled = -1    else:        raise ValueError("Incorrect value for commanded")    success_whole_array = False    newly_fulfilled_points = []    printout_condition=False    while success_whole_array==False:                                            built = np.asarray([[0,0]])        tree = cKDTree(built)                while True:                                    n_not_fulfilled = 0            if not try_fulfill:                if built.shape[0]>=n:                    success_whole_array = True                    break            else:                #n_min_possible = (1 + (8 * commanded.shape[0] + 1 ) ** .5 ) / 2                if built.shape[0]>1:                    _, n_not_fulfilled, fulfilled, not_fulfilled = check_fulfillment(commanded,built,fulfill_tolerance)                    if n_not_fulfilled == 0:                        success_whole_array = True                        break            success_new_dish = False            if try_fulfill and built.shape[0]>1:                printout_condition = built.shape[0]%10==0 or (not_fulfilled.shape[0]<1000)            while not success_new_dish:                # Generate a new antpos at a random direction and distance                angle = np.random.uniform(0, 2*np.pi)                distance = np.random.uniform(diameter, max_array_size/2)                new_antpos = np.asarray([np.cos(angle) * distance, np.sin(angle) * distance])                if tree.query(new_antpos)[0] >= diameter:                    # Add the new antpos if it passes all checks and we're at the beginning                    if built.shape[0]<=1 or n_not_fulfilled == 0:                        if try_fulfill and built.shape[0]>1:                            newly_fulfilled_points.append(get_n_new_fulfilled(new_antpos,built,not_fulfilled,fulfill_tolerance))                        built = np.vstack([built, new_antpos])                        tree = cKDTree(built)  # Rebuild KDTree with the new antpos                        success_new_dish = True                        n_failed_attempts = 0                    else:                        built_temp = np.vstack([built,new_antpos])                        _, n_not_fulfilled_temp,_,_ = check_fulfillment(commanded,built_temp,fulfill_tolerance)                        if n_not_fulfilled_temp<n_not_fulfilled or not try_fulfill:                            if try_fulfill and built.shape[0]>1:                                newly_fulfilled_points.append(get_n_new_fulfilled(new_antpos,built,not_fulfilled,fulfill_tolerance))                            built = np.vstack([built, new_antpos])                            tree = cKDTree(built)  # Rebuild KDTree with the new antpos                            success_new_dish = True                            n_failed_attempts = 0                else:                    n_failed_attempts+=1                    if n_failed_attempts>0 and n_failed_attempts % 100000 == 0:                        print(f"Failed attempts: {n_failed_attempts}/{max_failed_attempts}")                if n_failed_attempts >= max_failed_attempts:                    print(f"Maximum number of failed attempts reached ({max_failed_attempts}), no spot for new dish found, starting over.")                    break                        if len(built) % 100 == 0 and not try_fulfill:                print(f"Generated {built.shape[0]}/{n} antennas...")            if n_failed_attempts >= max_failed_attempts:                break                                                if show_plot and built.shape[0]%show_plot_skip==0:                clear_output(wait=True)                #plt.pause(0.01)                #built_uvs = antpos_to_uv(built)                ax[0].plot(commanded[:,0],commanded[:,1],'.',color='k',alpha=0.15,label='Commanded points')                ax[0].plot(fulfilled[:,0],fulfilled[:,1],'.',color='#00ff00',label='Fulfilled points')                ax[0].set_title('uv plane')                ax[0].set_xlabel(r'$u$')                ax[0].set_ylabel(r'$v$')                #ax[0].legend()                ax[1].plot(built[:,0],built[:,1],'.',color='k')                ax[1].set_title('Array')                ax[1].set_xlabel('EW')                ax[1].set_ylabel('NS')                ax[2].plot(range(len(newly_fulfilled_points)),newly_fulfilled_points,color='k')                ax[2].set_ylabel('Number of newly fulfilled points')                ax[2].set_xlabel('New antenna rank')                ax[2].grid()                for i in range(2):                    ax[i].set_aspect('equal', adjustable='box')                #if built.shape[0]%10==0:                display(fig)            if verbose and show_plot and built.shape[0]%show_plot_skip==0:                n_newly_fulfilled = newly_fulfilled_points[-1]                print('{:d} newly fulfilled points'.format(n_newly_fulfilled))                print('{:d} total antennas built'.format(built.shape[0]))                print('{:d}/{:d} commanded points remain to be fulfilled'.format(not_fulfilled.shape[0],commanded.shape[0]))            if verbose and not show_plot:                if printout_condition:                    clear_output(wait=True)                    n_newly_fulfilled = newly_fulfilled_points[-1]                    print('{:d} newly fulfilled points'.format(n_newly_fulfilled))                    print('{:d} total antennas built'.format(built.shape[0]))                    print('{:d}/{:d} commanded points remain to be fulfilled'.format(not_fulfilled.shape[0],commanded.shape[0]))                                    print('Done.')    print('Array size is now: {:.2f} wavelengths'.format(get_array_size(built)))    print('{:d} total antennas built'.format(built.shape[0]))    if try_fulfill:        n_fulfilled, n_not_fulfilled, fulfilled, not_fulfilled = check_fulfillment(commanded,built,fulfill_tolerance)        print('{:d}/{:d} commanded points remain to be fulfilled'.format(n_not_fulfilled,commanded.shape[0]))    plt.close()    return builtdef create_array_random_on_grid(n=0, commanded = -1,diameter=8.54, max_array_size=300, fulfill_tolerance=0.5,n_side_mesh=1000,show_plot = True,random_seed = 11141):    if isinstance(commanded, np.ndarray):        try_fulfill = True        n_not_fulfilled = commanded.shape[0]    elif isinstance(commanded, int):        try_fulfill = False        n_not_fulfilled = -1    else:        raise ValueError("Incorrect value for commanded")    np.random.seed(random_seed)        array_min_x = -max_array_size / 2    array_max_x = max_array_size / 2    array_min_y = -max_array_size / 2    array_max_y = max_array_size / 2        x = np.linspace(array_min_x, array_max_x, n_side_mesh)    y = np.linspace(array_min_y, array_max_y, n_side_mesh)    xx, yy = np.meshgrid(x, y)        grid_points = np.column_stack((xx.ravel(), yy.ravel()))        # Calculate distances from origin for each point    distances = np.linalg.norm(grid_points, axis=1)        # Find indices of points within the desired radius    valid_indices = distances <= max_array_size / 2        # Filter out points outside the desired radius    grid_points = grid_points[valid_indices]    print('Grid generated...')    built = np.asarray([[0,0]])    new_antpos = built[0]        #if show_plot:            n_not_fulfilled_array = [n_not_fulfilled]    grid_points_left_array = []        while True:                distances = np.linalg.norm(grid_points[:, None] - new_antpos.reshape(1,-1), axis=2)        within_distance = np.any(distances < diameter, axis=1)        grid_points = grid_points[~within_distance]        grid_points_left_array.append(grid_points.shape[0])        if built.shape[0]>1:            if try_fulfill:                _,n_not_fulfilled,fulfilled,_ = check_fulfillment(commanded,built,fulfill_tolerance)                n_not_fulfilled_array.append(n_not_fulfilled)        if built.shape[0]>=n and not try_fulfill:            print('Built the required number of antennas.')            break        elif grid_points.shape[0]==0:            print('No more grid points.')            print(f'{built.shape[0]} antennas placed, {n_not_fulfilled} commanded baselines yet to be fulfilled.')            break        elif n_not_fulfilled==0:            print('Fulfilled all commanded baselines.')            break        if built.shape[0]%10==0:                        if show_plot:                                clear_output(wait=True)                plt.pause(0.01)                                if try_fulfill:                    fig,ax = plt.subplots(1,3,figsize=(18,5))                    ax2_twin = ax[2].twinx()                                        ax[0].plot(commanded[:,0],commanded[:,1],'.',color='k',alpha=0.15,label='Commanded antpos')                    ax[0].plot(fulfilled[:,0],fulfilled[:,1],'.',color='#00ff00',label='Fulfilled antpos')                    ax[0].set_title('uv plane')                    ax[0].set_xlabel(r'$u$')                    ax[0].set_ylabel(r'$v$')                    #ax[0].legend()                    ax[1].plot(built[:,0],built[:,1],'.',color='#aa00aa')                    ax[1].plot(grid_points[:,0],grid_points[:,1],'.',color='#00aa00')                    ax[1].set_title('Array')                    ax[1].set_xlabel('EW')                    ax[1].set_ylabel('NS')                    ax[2].plot(n_not_fulfilled_array,color='b')                    ax[2].set_ylabel('Remaining commanded uv points to fulfill',color='b')                    ax[2].set_xlabel('New antenna rank')                    ax[2].set_ylim([0,commanded.shape[0]])                    ax2_twin.plot(grid_points_left_array,color='r')                    ax2_twin.set_ylabel('Remaining grid points',color='r')                    ax2_twin.set_xlabel('New antenna rank')                    ax2_twin.set_ylim([0,grid_points_left_array[0]])                                    else:                    fig,ax = plt.subplots(1,2,figsize=(12,5))                    ax[0].plot(fulfilled[:,0],fulfilled[:,1],color='#00ff00',label='Fulfilled antpos')                    ax[0].set_title('uv plane')                    ax[0].set_xlabel(r'$u$')                    ax[0].set_ylabel(r'$v$')                    #ax[0].legend()                    ax[1].plot(built[:,0],built[:,1],'.',color='#aa00aa')                    ax[1].plot(grid_points[:,0],grid_points[:,1],'.',color='#00aa00')                    ax[1].set_title('Array')                    ax[1].set_xlabel('EW')                    ax[1].set_ylabel('NS')                for i in range(2):                    ax[i].set_aspect('equal', adjustable='box')                display(fig)            print(f'{built.shape[0]} antennas placed, {n_not_fulfilled} commanded baselines yet to be fulfilled, {grid_points.shape[0]} grid points left...')        i = int(round(np.random.uniform() * (grid_points.shape[0] - 1)))        if try_fulfill:            new_antpos_temp = grid_points[i]            built_temp = np.vstack([built,new_antpos_temp])            _,n_not_fulfilled_temp,_,_ = check_fulfillment(commanded,built_temp,fulfill_tolerance)            if n_not_fulfilled_temp < n_not_fulfilled:                new_antpos = new_antpos_temp                built = np.vstack([built,new_antpos])        else:            built = np.vstack([built,grid_points[i]])        print('Array size is now: {:.2f} wavelengths'.format(get_array_size(built)))    print('{:d} total antennas built'.format(built.shape[0]))    if try_fulfill:        n_fulfilled, n_not_fulfilled, fulfilled, not_fulfilled = check_fulfillment(commanded,built,fulfill_tolerance)        print('{:d}/{:d} commanded points remain to be fulfilled'.format(n_not_fulfilled,commanded.shape[0]))    return built , grid_points