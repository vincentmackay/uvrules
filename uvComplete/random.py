#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Thu Feb 15 12:27:51 2024@author: vincent"""import numpy as npimport matplotlib.pyplot as pltfrom scipy.spatial import cKDTreefrom IPython.display import clear_outputfrom uvComplete.utils import check_fulfillmentrandom_seed = 11141def create_random_array(n=200, commanded = -1, diameter=8.54,max_array_size=300, fulfill_tolerance = 0.5, max_failed_attempts = 100000):    # Initialize antpos array with a single random point    np.random.seed(random_seed)        if isinstance(commanded, np.ndarray):        try_fulfill = True        n_not_fulfilled = commanded.shape[0]    elif isinstance(commanded, int):        try_fulfill = False        n_not_fulfilled = -1    else:        raise ValueError("Incorrect value for commanded")    success_whole_array = False    while success_whole_array==False:                                    antpos = np.array([[0,0]])        tree = cKDTree(antpos)                while True:                                                        n_not_fulfilled = 0            if not try_fulfill:                if len(antpos)>=n:                    success_whole_array = True                    break            else:                #n_min_possible = (1 + (8 * commanded.shape[0] + 1 ) ** .5 ) / 2                if antpos.shape[0]>1:                    _, n_not_fulfilled, _, _ = check_fulfillment(commanded,antpos,fulfill_tolerance)                    if n_not_fulfilled == 0:                        success_whole_array = True                        break            success_new_dish = False            while not success_new_dish:                # Generate a new antpos at a random direction and distance                angle = np.random.uniform(0, 2*np.pi)                distance = np.random.uniform(diameter, max_array_size/2)                new_antpos = np.array([np.cos(angle) * distance, np.sin(angle) * distance])                                    if tree.query(new_antpos)[0] >= diameter:                    # Add the new antpos if it passes all checks and we're at the beginning                    if antpos.shape[0]<=1 or n_not_fulfilled == 0:                        antpos = np.vstack([antpos, new_antpos])                        tree = cKDTree(antpos)  # Rebuild KDTree with the new antpos                        success_new_dish = True                        n_failed_attempts = 0                    else:                        temp_antpos = np.vstack([antpos,new_antpos])                        _, n_not_fulfilled_temp,_,_ = check_fulfillment(commanded,temp_antpos,fulfill_tolerance)                        if n_not_fulfilled_temp<n_not_fulfilled or not try_fulfill:                            antpos = np.vstack([antpos, new_antpos])                            tree = cKDTree(antpos)  # Rebuild KDTree with the new antpos                            success_new_dish = True                            n_failed_attempts = 0                else:                    n_failed_attempts+=1                    if n_failed_attempts>0 and n_failed_attempts % 100000 == 0:                        print(f"Failed attempts: {n_failed_attempts}/{max_failed_attempts}")                if n_failed_attempts >= max_failed_attempts:                    print(f"Maximum number of failed attempts reached ({max_failed_attempts}), no spot for new dish found, starting over.")                    break                        if len(antpos) % 100 == 0 or (n_not_fulfilled<1000 and len(antpos) % 10 == 0 and try_fulfill):                if not try_fulfill:                    print(f"Generated {len(antpos)}/{n} antpos...")                else:                    if n_not_fulfilled != 0:                        print(f"Generated {len(antpos)} antpos, {n_not_fulfilled} baselines remaining to fulfill...")            if n_failed_attempts >= max_failed_attempts:                break                print('Done.')    return antposdef create_random_array_on_grid(n=0, commanded = -1,diameter=8.54, max_array_size=300, fulfill_tolerance=0.5,n_side_mesh=1000,show_plot = True):    if isinstance(commanded, np.ndarray):        try_fulfill = True        n_not_fulfilled = commanded.shape[0]    elif isinstance(commanded, int):        try_fulfill = False        n_not_fulfilled = -1    else:        raise ValueError("Incorrect value for commanded")    np.random.seed(random_seed)        array_min_x = -max_array_size / 2    array_max_x = max_array_size / 2    array_min_y = -max_array_size / 2    array_max_y = max_array_size / 2        x = np.linspace(array_min_x, array_max_x, n_side_mesh)    y = np.linspace(array_min_y, array_max_y, n_side_mesh)    xx, yy = np.meshgrid(x, y)        grid_points = np.column_stack((xx.ravel(), yy.ravel()))        # Calculate distances from origin for each point    distances = np.linalg.norm(grid_points, axis=1)        # Find indices of points within the desired radius    valid_indices = distances <= max_array_size / 2        # Filter out points outside the desired radius    grid_points = grid_points[valid_indices]    print('Grid generated...')    antpos = np.array([[0,0]])    new_antpos = antpos[0]        #if show_plot:            n_not_fulfilled_array = [n_not_fulfilled]    grid_points_left_array = []        while True:                distances = np.linalg.norm(grid_points[:, None] - new_antpos.reshape(1,-1), axis=2)        within_distance = np.any(distances < diameter, axis=1)        grid_points = grid_points[~within_distance]        grid_points_left_array.append(grid_points.shape[0])        if antpos.shape[0]>1:            if try_fulfill:                _,n_not_fulfilled,fulfilled,_ = check_fulfillment(commanded,antpos,fulfill_tolerance)                n_not_fulfilled_array.append(n_not_fulfilled)        if antpos.shape[0]>=n and not try_fulfill:            print('Built the number of antennas commanded.')            break        elif grid_points.shape[0]==0:            print('No more grid points.')            print(f'{antpos.shape[0]} antennas placed, {n_not_fulfilled} commanded baselines yet to be fulfilled.')            break        elif n_not_fulfilled==0:            print('Fulfilled all commanded baselines.')            break        if antpos.shape[0]%50==0:                        if show_plot:                                clear_output(wait=True)                plt.pause(0.01)                                if try_fulfill:                    fig,ax = plt.subplots(1,3,figsize=(18,5))                    ax2_twin = ax[2].twinx()                                        ax[0].plot(commanded[:,0],commanded[:,1],color='k',alpha=0.15,label='Commanded antpos')                    ax[0].plot(fulfilled[:,0],fulfilled[:,1],color='#00ff00',label='Fulfilled antpos')                    ax[0].set_title('uv plane')                    ax[0].set_xlabel(r'$u$')                    ax[0].set_ylabel(r'$v$')                    #ax[0].legend()                    ax[1].plot(antpos[:,0],antpos[:,1],'.',color='#aa00aa')                    ax[1].plot(grid_points[:,0],grid_points[:,1],'.',color='#00aa00')                    ax[1].set_title('Array')                    ax[1].set_xlabel('EW')                    ax[1].set_ylabel('NS')                    ax[2].plot(n_not_fulfilled_array,color='b')                    ax[2].set_ylabel('Remaining commanded uv points to fulfill',color='b')                    ax[2].set_xlabel('New antenna rank')                    ax[2].set_ylim([0,commanded.shape[0]])                    ax2_twin.plot(grid_points_left_array,color='r')                    ax2_twin.set_ylabel('Remaining grid points',color='r')                    ax2_twin.set_xlabel('New antenna rank')                    ax2_twin.set_ylim([0,grid_points_left_array[0]])                                    else:                    fig,ax = plt.subplots(1,2,figsize=(12,5))                    ax[0].plot(fulfilled[:,0],fulfilled[:,1],color='#00ff00',label='Fulfilled antpos')                    ax[0].set_title('uv plane')                    ax[0].set_xlabel(r'$u$')                    ax[0].set_ylabel(r'$v$')                    #ax[0].legend()                    ax[1].plot(antpos[:,0],antpos[:,1],'.',color='#aa00aa')                    ax[1].plot(grid_points[:,0],grid_points[:,1],'.',color='#00aa00')                    ax[1].set_title('Array')                    ax[1].set_xlabel('EW')                    ax[1].set_ylabel('NS')                for i in range(2):                    ax[i].set_aspect('equal', adjustable='box')                #display(fig)            print(f'{antpos.shape[0]} antennas placed, {n_not_fulfilled} commanded baselines yet to be fulfilled, {grid_points.shape[0]} grid points left...')        i = int(round(np.random.uniform() * (grid_points.shape[0] - 1)))        if try_fulfill:            new_antpos_temp = grid_points[i]            temp_antpos = np.vstack([antpos,new_antpos_temp])            _,n_not_fulfilled_temp,_,_ = check_fulfillment(commanded,temp_antpos,fulfill_tolerance)            if n_not_fulfilled_temp < n_not_fulfilled:                new_antpos = new_antpos_temp                antpos = np.vstack([antpos,new_antpos])        else:            antpos = np.vstack([antpos,grid_points[i]])            return antpos , grid_points