#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Thu Feb 15 12:27:51 2024@author: vincent"""import numpy as npimport matplotlib.pyplot as pltfrom scipy.spatial.distance import pdistfrom scipy.spatial import cKDTreeimport itertoolsrandom_seed = 11141def plot_array(built):    fig,ax = plt.subplots(1,1)    ax.plot(built[:,0],built[:,1],'.')    ax.set_xlabel(r'EW [$\lambda$]')    ax.set_ylabel(r'NS [$\lambda$]')    ax.set_aspect('equal')    return fig,ax    def collision_check(built,diameter):    # Returns true if there is a collision    return get_min_distance(built)<=diametercheck_collision = collision_check # just an alias because sometimes I mix them updef get_min_distance(built):    # Returns the minimum distance between any two points    return np.min(pdist(built, 'euclidean'))def get_min_distance_from_new_point(built, new_point):    # Returns the minimum distance between an array that is currently built and a new point    return np.min(np.linalg.norm(built-new_point,axis=1))    def get_array_size(built):    # Returns the physical size of the array    return np.max(pdist(built, 'euclidean'))get_max_distance = get_array_size # just an alias because "get_max_distance" follows the "get_min_distance" conventiondef get_n_new_fulfilled(new_antpos,built,not_fulfilled,fulfill_tolerance, p_norm =  np.inf):        # Returns how many new commanded uvs are fulfilled when adding new_ant to built        # Compute the uvsbuilt_uvs = antpos_to_uv(built)  # Assuming this function converts built positions to uvs            # Create a KD-tree    tree = cKDTree(new_uvs)        # Query the tree for each point in not_fulfilled to find if there's at least one point within fulfill_tolerance    counts = tree.query_ball_point(not_fulfilled, r=fulfill_tolerance, p = p_norm) # this step takes 0.01 seconds, which is long        # Count how many of these queries return at least one point    n_new_fulfilled = sum(len(count) > 0 for count in counts)    return n_new_fulfilleddef check_fulfillment(commanded, built, fulfill_tolerance, p_norm = np.inf):    # Returns the number of fulfilled and unfulfilled points, along with the corresponding arrays    built_uvs = antpos_to_uv(built)        # Build a KD-tree for built_uvs    tree = cKDTree(built_uvs)        # Find indices of commanded points that are within the threshold distance of points in built_uvs    idx_fulfilled = tree.query_ball_point(commanded, r=fulfill_tolerance, p = p_norm)        # Determine which points in commanded are close to any in built_uvs    fulfilled_mask = np.array([bool(idx) for idx in idx_fulfilled])    # Determine far antpos as those not close to any point in built_uvs    fulfilled = commanded[fulfilled_mask]    not_fulfilled = commanded[~fulfilled_mask]        return fulfilled.shape[0], not_fulfilled.shape[0], fulfilled, not_fulfilleddef antpos_to_uv(antpos):    # Returns the uv points from a given array of antenna positions        n_ants = len(antpos)    n_bls = int(n_ants*(n_ants-1)/2)    uv_points = [None] * n_bls    # Generate all pairwise combinations of antenna positions    i_pair = 0    for pos1, pos2 in itertools.combinations(antpos, 2):        # Compute the difference between positions to get the uv point        u = pos2[0] - pos1[0]        v = pos2[1] - pos1[1]        if v>=0:            uv_points[i_pair] = ((u, v))        else:            uv_points[i_pair] = ((-u, -v))        i_pair+=1    return list(set(uv_points))def generate_uv_grid(uv_cell_size=1., min_u=-100, max_u=100, min_v=0, max_v=100, min_bl=10, max_bl=100, show_plot = True):    # Returns a grid of antpos in a half annulus, without the (u<0,v=0) segment        uv_points = []    for u in np.arange(min_u, max_u + uv_cell_size, uv_cell_size):        for v in np.arange(min_v, max_v + uv_cell_size, uv_cell_size):            distance = np.sqrt(u**2 + v**2)            if min_bl < distance <= max_bl:                if not (u<0 and v==0):                    #print(u,v)                    uv_points.append((u, v))    uv_points = np.array(uv_points)    if show_plot:        fig,ax = plt.subplots(1,1,figsize=[10,5])        ax.plot(uv_points[:,0],uv_points[:,1],'.',markersize=1,color='k')        ax.set_aspect('equal', adjustable='box')        ax.set_title('Commanded points')        ax.set_xlim(min_u-1, max_u+1)        ax.set_ylim(min_v-1, max_v+1)        ax.grid()    return uv_points