#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Thu Feb 15 12:27:51 2024@author: vincent"""import numpy as npimport matplotlib.pyplot as pltfrom IPython.display import display, clear_outputimport itertoolsimport picklefrom uvComplete.utils import check_fulfillment, get_array_size, get_n_new_fulfilled, get_min_distance_from_new_point, collision_checkfrom multiprocessing import Pooldef create_slow_rules_array(commanded, diameter = 8.54, max_array_size = 300, fulfill_tolerance = 0.5, order = -1, show_plot = True, save_file = False, save_name = 'long_rules', verbose = True):    if show_plot:        fig,ax = plt.subplots(1,3,figsize=(15,5))        # Build the first dish    built = np.array([[0,0]])    if verbose:        print('Before even beginning, have:')        print('{:d} antennas built'.format(built.shape[0]))            # sort by longest to shortest baseline    commanded = commanded[np.argsort(order * np.linalg.norm(commanded, axis=1))]        newly_fulfilled_points = []        not_fulfilled = np.copy(commanded)        # do the first iteration, which is trivial    built = np.vstack([built, not_fulfilled[0]])    n_fulfilled, n_not_fulfilled, fulfilled, not_fulfilled = check_fulfillment(commanded,built, fulfill_tolerance)            while(not_fulfilled.shape[0]>=1):        max_new_fulfilled = 0        min_built_size = get_array_size(built)        max_min_distance_from_new = 0        success = False        favored_i = 0        favored_flip = 1        favored_k = 0        # iterate over all combinations of built antennas and unfulfilled uv point        for i,k in itertools.product(range(built.shape[0]), range(not_fulfilled.shape[0])):            # try both the positive and negative position            for flip in [1,-1]:                new_antpos = built[i] + flip * not_fulfilled[k]                                # try and add one antenna at the longest commanded-but-not-fulfilled distance from point i                built_temp = np.vstack([built, new_antpos]) # 50 us                # check how many are newly fulfilled                n_new_fulfilled = get_n_new_fulfilled(new_antpos,built,not_fulfilled, fulfill_tolerance) # 15 ms                # check what's the shortest distance of the new point from any already built antenna                min_distance_from_new = get_min_distance_from_new_point(built, new_antpos) # 215 us                                # also check the size of the array                built_temp_size = get_array_size(built_temp) #241 us                                # check if there's no collision and that we're still within max size                if (not collision_check(built_temp,diameter)) and built_temp_size<max_array_size: #245 us                    success = True                    if n_new_fulfilled > max_new_fulfilled:                        max_new_fulfilled = n_new_fulfilled                        favored_i = i                        favored_k = k                        favored_flip = flip                    elif n_new_fulfilled == max_new_fulfilled:                        if min_distance_from_new > max_min_distance_from_new:                            max_min_distance_from_new = min_distance_from_new                            favored_i = i                            favored_flip = flip                            favored_k = k                        elif min_distance_from_new == max_min_distance_from_new:                            if built_temp_size < min_built_size:                                min_built_size = built_temp_size                                favored_i = i                                favored_flip = flip                                favored_k = k                        if success == False:            print('Array is full for this set of parameters, quitting.')            return built            break                    built = np.vstack([built,built[favored_i] + favored_flip*not_fulfilled[favored_k]])        n_fulfilled, n_not_fulfilled, fulfilled, not_fulfilled = check_fulfillment(commanded,built, fulfill_tolerance)        not_fulfilled = not_fulfilled[np.argsort(order * np.linalg.norm(not_fulfilled, axis=1))]                newly_fulfilled_points.append(max_new_fulfilled)                if show_plot:            clear_output(wait=True)            plt.pause(0.01)            #built_uvs = antpos_to_uv(built)            ax[0].plot(commanded[:,0],commanded[:,1],'.',color='k',alpha=0.15,label='Commanded points')            ax[0].plot(fulfilled[:,0],fulfilled[:,1],'.',color='#00ff00',label='Fulfilled points')            ax[0].set_title('uv plane')            ax[0].set_xlabel(r'$u$')            ax[0].set_ylabel(r'$v$')            #ax[0].legend()            ax[1].scatter(*zip(*built),marker='o', s=20,color='k')            ax[1].set_title('Array')            ax[1].set_xlabel('EW')            ax[1].set_ylabel('NS')            ax[2].plot(range(len(newly_fulfilled_points)),newly_fulfilled_points,color='k')            ax[2].set_ylabel('Number of newly fulfilled points')            ax[2].set_xlabel('New antenna rank')            for i in range(2):                ax[i].set_aspect('equal', adjustable='box')            #if built.shape[0]%10==0:            display(fig)        if verbose:            print('Array size is now: {:.2f} wavelengths'.format(min_built_size))            print('{:d} newly fulfilled points'.format(max_new_fulfilled))            print('{:d} total antennas built'.format(built.shape[0]))            print('{:d}/{:d} commanded points remain to be fulfilled'.format(not_fulfilled.shape[0],commanded.shape[0]))        plt.close()    if save_file:        # Saving the variable to disk        with open('built_'+save_name+'.pkl', 'wb') as file:            pickle.dump(built, file)    return built    if verbose:        print('Done.')        def create_quick_rules_array(commanded, diameter = 8.54, max_array_size = 300, fulfill_tolerance = 0.5, order = -1, show_plot = True, save_file = False,save_name='quick_rules', verbose = True, n_max_antennas = -1,within_bounds = False):    if show_plot:        fig,ax = plt.subplots(1,3,figsize=(15,5))        # Build the first dish    built = np.array([[0,0]])    if verbose:        print('Before even beginning, have:')        print('{:d} antennas built'.format(built.shape[0]))            # sort by longest to shortest baseline    commanded = commanded[np.argsort(order * np.linalg.norm(commanded, axis=1))]        newly_fulfilled_points = []        not_fulfilled = np.copy(commanded)        # do the first iteration, which is trivial    built = np.vstack([built, not_fulfilled[0]])    n_fulfilled, n_not_fulfilled, fulfilled, not_fulfilled = check_fulfillment(not_fulfilled,built, fulfill_tolerance)    not_fulfilled = not_fulfilled[np.argsort(order * np.linalg.norm(not_fulfilled, axis=1))]        while(not_fulfilled.shape[0]>=1):        if built.shape[0]==n_max_antennas:            break        success = False        favored_i = 0        favored_k = 0        favored_flip = 1                        # iterate over all combinations of built antennas and unfulfilled uv point        for i in range(built.shape[0]):            # iterate over all the not fulfilled baselines            for k in range(not_fulfilled.shape[0]):                # try both the positive and negative position                for flip in [1.,-1.]:                    new_antpos = built[i] + flip * not_fulfilled[k]                                        if within_bounds:                        if np.linalg.norm(new_antpos)>max_array_size/2:                            continue                                        # try and add one antenna at the longest commanded-but-not-fulfilled distance from point i                    built_temp = np.vstack([built,new_antpos]) # 50 us                        # check the size of the array                    if not within_bounds:                        built_temp_size = get_array_size(built_temp) #241 us                    else:                        built_temp_size = 0                                        # check if there's no collision and that we're still within max size                    if (not collision_check(built_temp,diameter)) and built_temp_size<max_array_size: #245 us                        success = True                        favored_i = i                        favored_k = k                        favored_flip = flip                        break                if success == True:                    break            if success == True:                break                                if success == False:            print('Array is full for this set of parameters, quitting.')            return built            break                    new_antpos = built[favored_i] + favored_flip*not_fulfilled[favored_k]        n_newly_fulfilled = get_n_new_fulfilled(new_antpos,built,not_fulfilled,fulfill_tolerance)        built = np.vstack([built,new_antpos])        n_fulfilled, n_not_fulfilled, fulfilled, not_fulfilled = check_fulfillment(commanded,built, fulfill_tolerance)        not_fulfilled = not_fulfilled[np.argsort(order * np.linalg.norm(not_fulfilled, axis=1))]                newly_fulfilled_points.append(n_newly_fulfilled)                printout_condition = built.shape[0]%10==0 or (not_fulfilled.shape[0]<1000)          if show_plot:            clear_output(wait=True)            #plt.pause(0.01)            #built_uvs = antpos_to_uv(built)            ax[0].plot(commanded[:,0],commanded[:,1],'.',color='k',alpha=0.15,label='Commanded points')            ax[0].plot(fulfilled[:,0],fulfilled[:,1],'.',color='#00ff00',label='Fulfilled points')            ax[0].set_title('uv plane')            ax[0].set_xlabel(r'$u$')            ax[0].set_ylabel(r'$v$')            #ax[0].legend()            ax[1].plot(built[:,0],built[:,1],'.',color='k')            ax[1].set_title('Array')            ax[1].set_xlabel('EW')            ax[1].set_ylabel('NS')            ax[2].plot(range(len(newly_fulfilled_points)),newly_fulfilled_points,color='k')            ax[2].set_ylabel('Number of newly fulfilled points')            ax[2].set_xlabel('New antenna rank')            for i in range(2):                ax[i].set_aspect('equal', adjustable='box')            #if built.shape[0]%10==0:            display(fig)        if verbose and show_plot:            print('{:d} newly fulfilled points'.format(n_newly_fulfilled))            print('{:d} total antennas built'.format(built.shape[0]))            print('{:d}/{:d} commanded points remain to be fulfilled'.format(not_fulfilled.shape[0],commanded.shape[0]))        if verbose and not show_plot:            if printout_condition:                clear_output(wait=True)                print('{:d} newly fulfilled points'.format(n_newly_fulfilled))                print('{:d} total antennas built'.format(built.shape[0]))                print('{:d}/{:d} commanded points remain to be fulfilled'.format(not_fulfilled.shape[0],commanded.shape[0]))                        plt.close()    if save_file:        # Saving the variable to disk        with open('built_'+save_name+'.pkl', 'wb') as file:            pickle.dump(built, file)    return built    if verbose:        array_size = get_array_size(built)        print('Done.')        print(f'Used {built.shape[0]} antennas to fulfill all baselines, array size is '+'{:.2f} wavelengths.'.format(array_size))                        def create_CBA_rules_array(commanded, diameter = 8.54, max_array_size = 300, fulfill_tolerance = 0.5, order = -1, show_plot = True, save_file = False, save_name = 'long_rules', verbose = True):    #CBA means "Choose Best Antenna," i.e. the algorithm loops over built     if show_plot:        fig,ax = plt.subplots(1,3,figsize=(15,5))        # Build the first dish    built = np.array([[0,0]])    if verbose:        print('Before even beginning, have:')        print('{:d} antennas built'.format(built.shape[0]))            # sort by longest to shortest baseline    commanded = commanded[np.argsort(order * np.linalg.norm(commanded, axis=1))]        newly_fulfilled_points = []        not_fulfilled = np.copy(commanded)        # do the first iteration, which is trivial    built = np.vstack([built, not_fulfilled[0]])    n_fulfilled, n_not_fulfilled, fulfilled, not_fulfilled = check_fulfillment(commanded,built, fulfill_tolerance)            while(not_fulfilled.shape[0]>=1):        max_new_fulfilled = 0        min_built_size = get_array_size(built)        max_min_distance_from_new = 0        success = False        favored_i = 0        favored_flip = 1        favored_k = 0        # iterate over all combinations of built antennas and unfulfilled uv point        for i,k in itertools.product(range(built.shape[0]), range(not_fulfilled.shape[0])):            # try both the positive and negative position            for flip in [1,-1]:                new_antpos = built[i] + flip * not_fulfilled[k]                                # try and add one antenna at the longest commanded-but-not-fulfilled distance from point i                built_temp = np.vstack([built, new_antpos]) # 50 us                # check how many are newly fulfilled                n_new_fulfilled = get_n_new_fulfilled(new_antpos,built,not_fulfilled, fulfill_tolerance) # 15 ms                # check what's the shortest distance of the new point from any already built antenna                min_distance_from_new = get_min_distance_from_new_point(built, new_antpos) # 215 us                                # also check the size of the array                built_temp_size = get_array_size(built_temp) #241 us                                # check if there's no collision and that we're still within max size                if (not collision_check(built_temp,diameter)) and built_temp_size<max_array_size: #245 us                    success = True                    if n_new_fulfilled > max_new_fulfilled:                        max_new_fulfilled = n_new_fulfilled                        favored_i = i                        favored_k = k                        favored_flip = flip                    elif n_new_fulfilled == max_new_fulfilled:                        if min_distance_from_new > max_min_distance_from_new:                            max_min_distance_from_new = min_distance_from_new                            favored_i = i                            favored_flip = flip                            favored_k = k                        elif min_distance_from_new == max_min_distance_from_new:                            if built_temp_size < min_built_size:                                min_built_size = built_temp_size                                favored_i = i                                favored_flip = flip                                favored_k = k                        if success == False:            print('Array is full for this set of parameters, quitting.')            return built            break                    built = np.vstack([built,built[favored_i] + favored_flip*not_fulfilled[favored_k]])        n_fulfilled, n_not_fulfilled, fulfilled, not_fulfilled = check_fulfillment(commanded,built, fulfill_tolerance)        not_fulfilled = not_fulfilled[np.argsort(order * np.linalg.norm(not_fulfilled, axis=1))]                newly_fulfilled_points.append(max_new_fulfilled)                if show_plot:            clear_output(wait=True)            plt.pause(0.01)            #built_uvs = antpos_to_uv(built)            ax[0].plot(commanded[:,0],commanded[:,1],'.',color='k',alpha=0.15,label='Commanded points')            ax[0].plot(fulfilled[:,0],fulfilled[:,1],'.',color='#00ff00',label='Fulfilled points')            ax[0].set_title('uv plane')            ax[0].set_xlabel(r'$u$')            ax[0].set_ylabel(r'$v$')            #ax[0].legend()            ax[1].scatter(*zip(*built),marker='o', s=20,color='k')            ax[1].set_title('Array')            ax[1].set_xlabel('EW')            ax[1].set_ylabel('NS')            ax[2].plot(range(len(newly_fulfilled_points)),newly_fulfilled_points,color='k')            ax[2].set_ylabel('Number of newly fulfilled points')            ax[2].set_xlabel('New antenna rank')            for i in range(2):                ax[i].set_aspect('equal', adjustable='box')            display(fig)            #if built.shape[0]%10==0:        if verbose:            print('Array size is now: {:.2f} wavelengths'.format(min_built_size))            print('{:d} newly fulfilled points'.format(max_new_fulfilled))            print('{:d} total antennas built'.format(built.shape[0]))            print('{:d}/{:d} commanded points remain to be fulfilled'.format(not_fulfilled.shape[0],commanded.shape[0]))        plt.close()    if save_file:        # Saving the variable to disk        with open('built_'+save_name+'.pkl', 'wb') as file:            pickle.dump(built, file)    return built    if verbose:        print('Done.')                        def create_slow_rules_parallelized_array(commanded, diameter = 8.54, max_array_size = 300, fulfill_tolerance = 0.5, order = -1, show_plot = True, save_file = False, save_name = 'long_rules', verbose = True, num_cores = 64):    if show_plot:        fig,ax = plt.subplots(1,3,figsize=(15,5))        # Build the first dish    built = np.array([[0,0]])    if verbose:        print('Before even beginning, have:')        print('{:d} antennas built'.format(built.shape[0]))            # sort by longest to shortest baseline    commanded = commanded[np.argsort(order * np.linalg.norm(commanded, axis=1))]        newly_fulfilled_points = []        not_fulfilled = np.copy(commanded)        # do the first iteration, which is trivial    built = np.vstack([built, not_fulfilled[0]])    n_fulfilled, n_not_fulfilled, fulfilled, not_fulfilled = check_fulfillment(commanded,built, fulfill_tolerance)    flips = np.array([-1,1])        def chunkify(lst, n):        for i in range(0, len(lst), n):            yield lst[i:i + n]        def find_local_extrema(chunk):        max_new_fulfilled = 0        min_built_size = get_array_size(built)        max_min_distance_from_new = 0        favored_i = favored_j = favored_k = None        success = False        for i,j,k in chunk:            new_antpos = built[i] + flips[k] * not_fulfilled[j]                        # try and add one antenna at the longest commanded-but-not-fulfilled distance from point i            built_temp = np.vstack([built, new_antpos]) # 50 us                # check how many are newly fulfilled            n_new_fulfilled = get_n_new_fulfilled(new_antpos,built,not_fulfilled, fulfill_tolerance) # 15 ms                # check what's the shortest distance of the new point from any already built antenna            min_distance_from_new = get_min_distance_from_new_point(built, new_antpos) # 215 us                        # also check the size of the array            built_temp_size = get_array_size(built_temp) #241 us                        # check if there's no collision and that we're still within max size            if (not collision_check(built_temp,diameter)) and built_temp_size<max_array_size: #245 us                success = True                    if n_new_fulfilled > max_new_fulfilled:                    max_new_fulfilled = n_new_fulfilled                    favored_i = i                    favored_j = j                    favored_k = k                elif n_new_fulfilled == max_new_fulfilled:                    if min_distance_from_new > max_min_distance_from_new:                        max_min_distance_from_new = min_distance_from_new                        favored_i = i                        favored_j = j                        favored_k = k                    elif min_distance_from_new == max_min_distance_from_new:                        if built_temp_size < min_built_size:                            min_built_size = built_temp_size                            favored_i = i                            favored_j = j                            favored_k = k        return success, max_new_fulfilled, max_min_distance_from_new, min_built_size, favored_i, favored_j, favored_k        while(not_fulfilled.shape[0]>=1):                all_combinations = list(itertools.product(range(built.shape[0]),range(not_fulfilled.shape[0]),range(2)))                        chunks = list(chunkify(all_combinations, len(all_combinations) // num_cores))                # Run parallel computation        with Pool(processes = num_cores) as pool:            results = pool.map(find_local_extrema, chunks)                # Aggregate results        global_success = False        global_max_new_fulfilled = 0        global_max_min_distance_from_new = 0        global_min_built_size = 0        global_favored_i = global_favored_j = global_favored_k = None                for result in results:            if result[0] == True:                global_success = True            if result[1] > global_max_new_fulfilled:                global_max_new_fulfilled,global_max_min_distance_from_new,global_min_built_size,global_favored_i,global_favored_j,global_favored_k = result[1:]            elif result[1] == global_max_new_fulfilled:                if result[2]>global_max_min_distance_from_new:                    global_max_new_fulfilled,global_max_min_distance_from_new,global_min_built_size,global_favored_i,global_favored_j,global_favored_k = result[1:]                elif result[2]==global_max_min_distance_from_new:                    if result[3]>global_min_built_size:                        global_max_new_fulfilled,global_max_min_distance_from_new,global_min_built_size,global_favored_i,global_favored_j,global_favored_k = result[1:]                                if global_success == False:            print('Array is full for this set of parameters, quitting.')            return built            break                            built = np.vstack([built,built[global_favored_i] + flips[global_favored_k]*not_fulfilled[global_favored_j]])        n_fulfilled, n_not_fulfilled, fulfilled, not_fulfilled = check_fulfillment(commanded,built, fulfill_tolerance)        not_fulfilled = not_fulfilled[np.argsort(order * np.linalg.norm(not_fulfilled, axis=1))]                newly_fulfilled_points.append(global_max_new_fulfilled)                if show_plot:            clear_output(wait=True)            plt.pause(0.01)            #built_uvs = antpos_to_uv(built)            ax[0].plot(commanded[:,0],commanded[:,1],'.',color='k',alpha=0.15,label='Commanded points')            ax[0].plot(fulfilled[:,0],fulfilled[:,1],'.',color='#00ff00',label='Fulfilled points')            ax[0].set_title('uv plane')            ax[0].set_xlabel(r'$u$')            ax[0].set_ylabel(r'$v$')            #ax[0].legend()            ax[1].scatter(*zip(*built),marker='o', s=20,color='k')            ax[1].set_title('Array')            ax[1].set_xlabel('EW')            ax[1].set_ylabel('NS')            ax[2].plot(range(len(newly_fulfilled_points)),newly_fulfilled_points,color='k')            ax[2].set_ylabel('Number of newly fulfilled points')            ax[2].set_xlabel('New antenna rank')            for i in range(2):                ax[i].set_aspect('equal', adjustable='box')            #if built.shape[0]%10==0:            display(fig)                    if verbose:            print('Array size is now: {:.2f} wavelengths'.format(global_min_built_size))            print('{:d} newly fulfilled points'.format(global_max_new_fulfilled))            print('{:d} total antennas built'.format(built.shape[0]))            print('{:d}/{:d} commanded points remain to be fulfilled'.format(not_fulfilled.shape[0],commanded.shape[0]))            if save_file:        # Saving the variable to disk        with open('built_'+save_name+'.pkl', 'wb') as file:            pickle.dump(built, file)    return built    if verbose:        print('Done.')